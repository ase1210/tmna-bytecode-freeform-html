!function(e){var n={};function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var a in e)t.d(r,a,function(n){return e[n]}.bind(null,a));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=0)}([function(module,exports,__webpack_require__){eval('const { config } = __webpack_require__(1);\n\nlooker.plugins.visualizations.add({\n  options: {\n    html_freeform: {\n      type: "string",\n      label:\n        "Freeform HTML. Use strings like ~1, ~2, or ~3 to access data inside the html",\n      display: "text",\n      default: "<div>Your custom HTML</div>",\n    },\n\n    styles_freeform: {\n      type: "string",\n      label: "Freeform Styles",\n      display: "text",\n      default: `@font-face {\n          font-family: Open Sans;\n          src: url( https://fonts.gstatic.com/s/opensans/v17/mem8YaGs126MiZpBA-UFVZ0b.woff2 );\n        }\n        div {\n          background-color: white;\n          text-align: center;\n        }`,\n    },\n    use_html_from_fields: {\n      type: "boolean",\n      label: "Use html from fields",\n      default: false, \n    },\n    rows_per_page: {\n      type: "number",\n      label: "Rows per page ÃŸ",\n      default: 5,\n    },\n    current_page: {\n      type: "number",\n      label: "Current page",\n      default: 1,\n    },\n    showPage: {\n      type: "boolean",\n      label: "Show Page",\n      default: true,\n    },\n    totalPages: {\n      type: "number",\n      label: "Total pages", \n      default: 1\n    },\n    showToggleButton: {\n      type: "boolean",\n      label: "Show Toggle pagination button",\n      default: true,\n    }\n  },\n\n  create: function (element, config) {\n    element.innerHTML = `<div class="html_freeform">Rendering...</div>`;\n  },\n  updateAsync: function (\n    data,\n    element,\n    config,\n    queryResponse,\n    details,\n    doneRendering\n  ) {\n    element.innerHTML = "";\n    let measure_fields = queryResponse.fields.measure_like.map((field) => {\n      // let key =    field.label\n      return field.name;\n    });\n    let dimension_fields = queryResponse.fields.dimension_like.map((field) => {\n      // let key =    field.label\n      return field.name;\n    });\n\n    let fields = dimension_fields.concat(measure_fields);\n\n    let existingStyleRef = document.getElementById("freeformStyle");\n    if (existingStyleRef) existingStyleRef.remove();\n\n    var styleEl = document.createElement("style");\n    styleEl.setAttribute("type", "text/css");\n    styleEl.setAttribute("id", "freeformStyle");\n    styleEl.innerHTML = config.styles_freeform;\n\n    document.head.appendChild(styleEl);\n\n    let html = "";\n    \n    let totalpages = Math.ceil(data.length / config.rows_per_page);\n    console.log("Totalpages: ", totalpages);\n    this.trigger("updateConfig", [{ totalPages: totalpages }]);\n    // let pagination = `\n    //   <div class="center" style="position: absolute; bottom: 0;">\n    if(totalpages > 0) {\n    let pagination = `\n      <div class="center" id="pageButtons">\n        <div class="pagination" style="display: ${config.showPage ? \'block\' : \'none\'}">\n          <a href="#" id="firstPageButton">&laquo;</a>\n          <a href="#" id="prevPageButton">&lsaquo;</a>\n          <a href="#"><span style="font-weight: bold">${config.current_page}</span> of <span id="vis_totalpages">${totalpages}</span></a>\n          <a href="#" id="nextPageButton">&rsaquo;</a>            \n          <a href="#" id="lastPageButton">&raquo;</a>            \n          \x3c!--<span>Total Pages: ${totalpages}</span>         \n          <span>Rows: ${data.length}</span>--\x3e\n        </div>\n        <div class="pagination" style="float: right;display: ${config.showToggleButton ? \'block\' : \'none\'}">\n          <a href="#" id="pageToggle">Toggle Pagination</a>\n        </div>\n      </div> </br>`;\n    html += pagination;\n\n    let lastRow = config.current_page * config.rows_per_page - 1;\n    let firstRow = lastRow - config.rows_per_page;\n\n    let filteredData = data.filter((row, i) => {\n      return i <= lastRow && i > firstRow;\n    });\n    for (var row of filteredData) {\n      let rowHtml = config.html_freeform || " ";\n      fields.map((field, i) => {\n        let cellHtml = " ";\n        var cell = row[field];\n        cellHtml = LookerCharts.Utils.htmlForCell(cell);\n        rowHtml = rowHtml.replace(`~${i + 1}~`, cellHtml);\n      });\n      html = html + rowHtml;\n    }\n\n    // let htmlWithPageBreak = html + `\n    //   <div style="page-break-before:always">&nbsp;</div> \n    //   <div style="page-break-after:always">&nbsp;</div> \n    // `\n    // element.innerHTML = htmlWithPageBreak;\n    element.innerHTML = html;\n  } else {\n    html = `<span style="font-weight: bold">No Records found</span>`\n    element.innerHTML = html;\n  }\n    \n    document.getElementById("pageToggle").addEventListener("click", (e) => togglePage(e,config));\n\n      const togglePage = (e, config) => {\n        e.preventDefault();\n        let pages = Math.ceil(data.length / config.rows_per_page);\n        if(pages == 1) {\n          this.trigger("updateConfig", [{ rows_per_page:  5, current_page: 1, showPage: true }]);\n          config.rows_per_page = 5;\n          config.current_page = 1;\n          config.showPage = true;\n        } else {\n          this.trigger("updateConfig", [{ rows_per_page:  data.length, current_page: 1, showPage: false }]);\n          config.rows_per_page = data.length;\n          config.current_page = 1;\n          config.showPage = false;\n        }\n        this.updateAsync(\n          data,\n          element,\n          config,\n          queryResponse,\n          details,\n          doneRendering\n        );\n      };\n\n    document.getElementById("nextPageButton").addEventListener("click", (e) => nextPage(e,config));\n      \n    document.getElementById("prevPageButton").addEventListener("click", (e) => prevPage(e,config));\n\n    document.getElementById("firstPageButton").addEventListener("click", (e) => firstPage(e,config));\n      \n    document.getElementById("lastPageButton").addEventListener("click", (e) => lastPage(e,config));\n\n      const nextPage = (e, config) => {\n        e.preventDefault();\n        let pages = Math.ceil(data.length / config.rows_per_page);\n        if(pages <= config.current_page) {\n          \n        } else {\n        let newPage = config.current_page + 1;\n        this.trigger("updateConfig", [{ current_page: newPage }]);\n        config.current_page = newPage;\n        this.updateAsync(\n          data,\n          element,\n          config,\n          queryResponse,\n          details,\n          doneRendering\n        );\n        }\n      };\n      \n      const prevPage = (e, config) => {\n        e.preventDefault();\n        if(config.current_page != 1) {\n        let newPage = config.current_page - 1;\n        this.trigger("updateConfig", [{ current_page: newPage }]);\n        config.current_page = newPage;\n        this.updateAsync(\n          data,\n          element,\n          config,\n          queryResponse,\n          details,\n          doneRendering\n        );\n        }\n      };\n\n      const firstPage = (e, config) => {\n        e.preventDefault();\n        this.trigger("updateConfig", [{ current_page: 1 }]);\n        config.current_page = 1;\n        this.updateAsync(\n          data,\n          element,\n          config,\n          queryResponse,\n          details,\n          doneRendering\n        );\n      };\n      const lastPage = (e, config) => {\n        e.preventDefault();\n        let pages = Math.ceil(data.length / config.rows_per_page);\n        let newPage = pages;\n        this.trigger("updateConfig", [{ current_page: newPage }]);\n        config.current_page = newPage;\n        this.updateAsync(\n          data,\n          element,\n          config,\n          queryResponse,\n          details,\n          doneRendering\n        );\n      };\n\n\n    doneRendering();\n  },\n});\n\n//# sourceURL=webpack:///./src/visualizations/html_freeform.js?')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?")}]);